<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>L√¨ X√¨ Arcade Casino Sim</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body{
      margin:0;
      background:
        radial-gradient(1000px 500px at 20% 0%, rgba(43,127,255,.18), transparent 60%),
        radial-gradient(900px 500px at 80% 20%, rgba(255,80,80,.14), transparent 60%),
        #070a10;
      color:#e8eef6;
    }
    .wrap{ max-width:1160px; margin:0 auto; padding:18px; display:grid; gap:14px; }
    .card{
      background: rgba(14,20,32,.74);
      border: 1px solid rgba(70,100,160,.38);
      border-radius:18px;
      padding:16px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    h1{ margin:0; font-size:20px; letter-spacing:.2px; }
    h2{ margin:0 0 10px; font-size:16px; opacity:.98; }
    .muted{ opacity:.85; font-size:13px; line-height:1.4; }

    .topbar{ display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:7px 12px; border-radius:999px;
      border: 1px solid rgba(70,100,160,.38);
      background: rgba(10,14,22,.7);
      font-size:12px;
    }
    .pill b{ font-weight:950; }

    .toolbar{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:flex-end; }
    .miniBtn{
      padding: 8px 10px; border-radius: 12px; border: 1px solid rgba(70,100,160,.38);
      background: rgba(10,14,22,.55); color:#e8eef6; cursor:pointer; font-weight:900;
    }

    .tabbar{ display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .tabbar button{
      padding:10px 12px; border-radius:999px;
      border: 1px solid rgba(70,100,160,.38);
      background: rgba(10,14,22,.55);
      color:#e8eef6; cursor:pointer; font-weight:950;
      transition: transform .12s ease, box-shadow .12s ease;
    }
    .tabbar button:hover{ transform: translateY(-1px); box-shadow: 0 10px 22px rgba(0,0,0,.25); }
    .tabbar button.active{ background: linear-gradient(135deg, #2b7fff, #7a5cff); border-color:transparent; }

    .tab{ display:none; }
    .tab.active{ display:block; }

    .grid{ display:grid; grid-template-columns: 1.2fr .8fr; gap:16px; }
    @media (max-width: 900px){ .grid{ grid-template-columns:1fr; } }

    label{ font-size:13px; opacity:.95; }
    input, select, textarea{
      width:100%; box-sizing:border-box;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(70,100,160,.38);
      background: rgba(10,14,22,.62);
      color:#e8eef6;
      outline:none;
    }
    input:focus, select:focus, textarea:focus{
      border-color: rgba(120,170,255,.7);
      box-shadow: 0 0 0 4px rgba(43,127,255,.18);
    }
    textarea{ min-height: 90px; resize: vertical; }

    button.primary{
      padding:12px 14px; border-radius:14px; border:0;
      background: linear-gradient(135deg, #2b7fff, #7a5cff);
      color:white; font-weight:950; cursor:pointer;
      box-shadow: 0 10px 26px rgba(43,127,255,.22);
      transition: transform .12s ease, filter .12s ease, box-shadow .12s ease;
    }
    button.primary:hover{ transform: translateY(-1px); filter: brightness(1.06); box-shadow: 0 14px 30px rgba(43,127,255,.28); }
    button.secondary{
      padding:12px 14px; border-radius:14px;
      border:1px solid rgba(70,100,160,.38);
      background: rgba(10,14,22,.55);
      color:#e8eef6; font-weight:950; cursor:pointer;
    }
    button:disabled{ opacity:.55; cursor:not-allowed; transform:none !important; }

    .result{
      font-size: 18px; font-weight: 950;
      padding: 12px;
      border-radius: 14px;
      background: rgba(10,14,22,.62);
      border: 1px solid rgba(70,100,160,.38);
      overflow:hidden;
    }
    .result.pop{ animation: pop .25s ease; }
    @keyframes pop{ 0%{ transform: scale(.98);} 60%{ transform: scale(1.03);} 100%{ transform: scale(1);} }

    .history{ font-size:13px; max-height: 180px; overflow:auto; }
    .history div{ padding:7px 0; border-bottom:1px solid rgba(255,255,255,.06); opacity:.95; }

    canvas#wheelCanvas{ width:100%; height:auto; background: rgba(10,14,22,.55); border-radius:18px; border:1px solid rgba(70,100,160,.38); }
    .chips{ display:flex; flex-wrap:wrap; gap:8px; }
    .chipBtn{
      padding:8px 10px; border-radius:999px;
      border:1px solid rgba(70,100,160,.38);
      background: rgba(10,14,22,.55);
      color:#e8eef6; cursor:pointer; font-weight:950;
    }

    .roulette-grid{ display:grid; grid-template-columns: repeat(3, 1fr); gap:6px; }
    .roulette-cell{
      border:1px solid rgba(70,100,160,.38);
      border-radius:12px;
      padding:10px;
      background: rgba(10,14,22,.55);
      display:flex; align-items:center; justify-content:space-between;
      font-weight:950;
      transition: transform .12s ease, box-shadow .12s ease;
    }
    .roulette-cell.active{
      outline:2px solid rgba(43,127,255,.95);
      box-shadow: 0 0 0 6px rgba(43,127,255,.15);
      transform: translateY(-1px);
    }
    .roulette-cell.red { background: linear-gradient(180deg, rgba(255,80,80,0.18), rgba(10,14,22,.55)); }
    .roulette-cell.black { background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(10,14,22,.55)); }
    .roulette-cell.green { background: linear-gradient(180deg, rgba(70,255,170,0.16), rgba(10,14,22,.55)); }

    .hand{ display:flex; flex-wrap:wrap; gap:8px; }
    .cardchip{
      border:1px solid rgba(70,100,160,.38);
      background: rgba(10,14,22,.62);
      border-radius:14px;
      padding:10px 12px;
      font-weight:950;
      min-width:68px;
      text-align:center;
      box-shadow: 0 10px 22px rgba(0,0,0,.18);
      animation: deal .18s ease;
    }
    @keyframes deal{ from{ transform: translateY(6px); opacity:0;} to{ transform: translateY(0); opacity:1;} }

    #fxCanvas{ position: fixed; inset:0; pointer-events:none; z-index:50; }
    .toastWrap{ position: fixed; right:14px; bottom:14px; display:grid; gap:10px; z-index:60; }
    .toast{
      width:min(360px, calc(100vw - 28px));
      background: rgba(10,14,22,.78);
      border: 1px solid rgba(70,100,160,.38);
      border-radius: 16px;
      padding: 10px 12px;
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      animation: toastIn .18s ease;
    }
    @keyframes toastIn{ from{ transform: translateY(8px); opacity:0;} to{ transform: translateY(0); opacity:1;} }
    .toast b{ font-weight:950; }

    /* Cursor overlay */
    .cursor{
      position: fixed;
      z-index: 70;
      pointer-events: none;
      transform: translate(-2px, -2px);
      display:none;
    }
    .cursor .dot{
      width:10px; height:10px; border-radius:999px;
      background: rgba(43,127,255,.95);
      box-shadow: 0 0 0 6px rgba(43,127,255,.15);
    }
    .cursor .tag{
      margin-top:6px;
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:6px 10px;
      border-radius:999px;
      border: 1px solid rgba(70,100,160,.38);
      background: rgba(10,14,22,.78);
      font-size:12px;
      font-weight:950;
      white-space:nowrap;
    }
    .cursor.p2 .dot{ background: rgba(255,80,80,.95); box-shadow: 0 0 0 6px rgba(255,80,80,.15); }
  </style>
</head>
<body>
  <canvas id="fxCanvas"></canvas>
  <div class="toastWrap" id="toastWrap"></div>

  <div class="cursor p1" id="cursorP1"><div class="dot"></div><div class="tag">P1</div></div>
  <div class="cursor p2" id="cursorP2"><div class="dot"></div><div class="tag">P2</div></div>

  <div class="wrap">
    <div class="card">
      <div class="topbar">
        <h1>üé∞ Casino Sim (chip ·∫£o)</h1>
        <div class="toolbar">
          <span class="pill">Status: <b id="mpStatus">Offline</b></span>
          <span class="pill">Room: <b id="roomCode">demo</b></span>
          <span class="pill">B·∫°n: <b id="playerCode">‚Äî</b></span>
          <span class="pill">Online: <b id="presence">‚Äî</b></span>
          <button class="miniBtn" id="copyLinkBtn">Copy link ph√≤ng</button>
          <button class="miniBtn" id="resetRoomBtn" title="Ch·ªâ P1 d√πng">Reset ph√≤ng</button>
        </div>
      </div>
      <div class="muted" style="margin-top:8px;">
        M√¥ ph·ªèng casino d√πng <b>chip ·∫£o</b>. Kh√¥ng n·∫°p/r√∫t/ƒë·ªïi ti·ªÅn th·∫≠t. N·∫øu Render ‚Äúsleep‚Äù/redeploy, s·ªë d∆∞ c√≥ th·ªÉ reset.
      </div>

      <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;">
        <span class="pill">P1 balance: <b id="balP1">‚Äî</b></span>
        <span class="pill">P2 balance: <b id="balP2">‚Äî</b></span>
        <span class="pill">Min bet: <b id="minBet">‚Äî</b></span>
        <span class="pill">Max bet: <b id="maxBet">‚Äî</b></span>
      </div>

      <div class="tabbar" role="tablist">
        <button class="active" data-tab-btn="wheel">Wheel</button>
        <button data-tab-btn="taixiu">T√†i/X·ªâu</button>
        <button data-tab-btn="blackjack">Blackjack</button>
        <button data-tab-btn="roulette">Roulette</button>
      </div>
    </div>

    <!-- WHEEL -->
    <section class="card tab active" data-tab="wheel">
      <h2>Wheel (bonus wheel) ‚Äî tr·∫£ theo h·ªá s·ªë c∆∞·ª£c (RTP ~97%)</h2>
      <div class="grid">
        <div class="row">
          <canvas id="wheelCanvas" width="720" height="720"></canvas>
          <div class="muted">x0: m·∫•t c∆∞·ª£c ¬∑ x1: ho√†n c∆∞·ª£c ¬∑ x2: th·∫Øng 1:1 ¬∑ x10: jackpot hi·∫øm</div>
        </div>

        <div class="row">
          <label>C∆∞·ª£c (chip)</label>
          <input id="wheelBet" type="number" min="10" step="10" />
          <div class="chips" id="wheelChips"></div>

          <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
            <button class="primary" id="wheelSpinBtn">SPIN</button>
            <button class="secondary" id="wheelClearBtn">Clear history</button>
          </div>

          <div class="result" id="wheelResult">‚Äî</div>
          <div class="history" id="wheelHistory"></div>
        </div>
      </div>
    </section>

    <!-- TAI XIU -->
    <section class="card tab" data-tab="taixiu">
      <h2>T√†i/X·ªâu (Sic Bo) ‚Äî 3 x√∫c x·∫Øc</h2>
      <div class="grid">
        <div class="row">
          <div class="muted">C∆∞·ª£c T√†i (11‚Äì17) / X·ªâu (4‚Äì10). <b>B·ªô ba (triple) thua</b> cho c∆∞·ª£c T√†i/X·ªâu. Tr·∫£ 1:1.</div>

          <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
            <div>
              <label>Ch·ªçn</label>
              <select id="txPick">
                <option value="tai">T√†i</option>
                <option value="xiu">X·ªâu</option>
              </select>
            </div>
            <div>
              <label>C∆∞·ª£c (chip)</label>
              <input id="txBet" type="number" min="10" step="10" />
            </div>
          </div>
          <div class="chips" id="txChips"></div>

          <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
            <button class="primary" id="txRollBtn">ROLL</button>
            <button class="secondary" id="txClearBtn">Clear history</button>
          </div>

          <div class="result" id="txResult">‚Äî</div>
          <div class="history" id="txHistory"></div>
        </div>

        <div class="row">
          <div class="card" style="padding:14px;">
            <h2>G·ª£i √Ω ‚Äúcasino-style‚Äù qu·∫£n l√Ω v·ªën</h2>
            <div class="muted">
              - ƒê·ª´ng c∆∞·ª£c qu√° 1‚Äì3% s·ªë d∆∞/1 v√°n.<br/>
              - N·∫øu chu·ªói thua d√†i, gi·∫£m c∆∞·ª£c v·ªÅ min bet.
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- BLACKJACK -->
    <section class="card tab" data-tab="blackjack">
      <h2>Blackjack ‚Äî tr·∫£ 1:1, Blackjack tr·∫£ 3:2</h2>
      <div class="grid">
        <div class="row">
          <div class="muted">Turn-based: P1 ch∆°i xong ‚Üí P2. Dealer r√∫t ƒë·∫øn ‚â•17.</div>

          <label>C∆∞·ª£c (chip) cho l∆∞·ª£t c·ªßa b·∫°n</label>
          <input id="bjBet" type="number" min="10" step="10" />
          <div class="chips" id="bjChips"></div>

          <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
            <button class="primary" id="bjDealBtn">DEAL</button>
            <button class="secondary" id="bjNewBtn" title="Ch·ªâ P1">New round</button>
          </div>

          <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
            <button class="primary" id="bjHitBtn" disabled>HIT</button>
            <button class="secondary" id="bjStandBtn" disabled>STAND</button>
          </div>

          <div class="card" style="padding:14px;">
            <div style="opacity:.86;font-size:13px;">Dealer</div>
            <div class="hand" id="bjDealerHand"></div>
            <div style="height:12px"></div>
            <div style="opacity:.86;font-size:13px;">Player</div>
            <div class="hand" id="bjPlayerHand"></div>
            <div style="height:12px"></div>
            <div class="result" id="bjResult">‚Äî</div>
          </div>

          <div class="history" id="bjHistory"></div>
        </div>

        <div class="row">
          <div class="card" style="padding:14px;">
            <h2>Paytable</h2>
            <div class="muted">
              - Th·∫Øng: +1√ó c∆∞·ª£c (return = 2√ó)<br/>
              - H√≤a: ho√†n c∆∞·ª£c (return = 1√ó)<br/>
              - Thua/bust: m·∫•t c∆∞·ª£c (return = 0)<br/>
              - Blackjack: +1.5√ó c∆∞·ª£c (return = 2.5√ó)
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- ROULETTE -->
    <section class="card tab" data-tab="roulette">
      <h2>Roulette (EU 0‚Äì36) ‚Äî ƒë·ªè/ƒëen 1:1, s·ªë 35:1</h2>
      <div class="grid">
        <div class="row">
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
            <div>
              <label>Lo·∫°i c∆∞·ª£c</label>
              <select id="rlBetType">
                <option value="red">ƒê·ªè</option>
                <option value="black">ƒêen</option>
                <option value="odd">L·∫ª</option>
                <option value="even">Ch·∫µn</option>
                <option value="low">1‚Äì18</option>
                <option value="high">19‚Äì36</option>
                <option value="number">S·ªë c·ª• th·ªÉ</option>
              </select>
            </div>
            <div id="rlNumberWrap" style="display:none;">
              <label>S·ªë (0‚Äì36)</label>
              <input id="rlNumber" type="number" min="0" max="36" value="7"/>
            </div>
          </div>

          <label>C∆∞·ª£c (chip)</label>
          <input id="rlBet" type="number" min="10" step="10" />
          <div class="chips" id="rlChips"></div>

          <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
            <button class="primary" id="rlSpinBtn">SPIN</button>
            <button class="secondary" id="rlClearBtn">Clear history</button>
          </div>

          <div class="result" id="rlResult">‚Äî</div>
          <div class="muted">B√†n s·ªë (highlight s·ªë v·ª´a ra)</div>
          <div class="roulette-grid" id="rlGrid"></div>
          <div class="history" id="rlHistory"></div>
        </div>

        <div class="row">
          <div class="card" style="padding:14px;">
            <h2>Paytable</h2>
            <div class="muted">
              - ƒê·ªè/ƒêen/Ch·∫µn/L·∫ª/1‚Äì18/19‚Äì36: tr·∫£ 1:1 (return 2√ó)<br/>
              - S·ªë c·ª• th·ªÉ: tr·∫£ 35:1 (return 36√ó)<br/>
              - Ra 0: thua h·∫øt c√°c c∆∞·ª£c even-money
            </div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    (() => {
      // ===== FX =====
      const fxCanvas = document.getElementById("fxCanvas");
      const fx = fxCanvas.getContext("2d");
      let fxW=0, fxH=0;
      function fxResize(){
        const dpr = window.devicePixelRatio || 1;
        fxW = Math.floor(innerWidth*dpr);
        fxH = Math.floor(innerHeight*dpr);
        fxCanvas.width = fxW; fxCanvas.height = fxH;
        fxCanvas.style.width = innerWidth+"px";
        fxCanvas.style.height = innerHeight+"px";
      }
      addEventListener("resize", fxResize); fxResize();

      const toastWrap = document.getElementById("toastWrap");
      function toast(title, msg){
        const el = document.createElement("div");
        el.className = "toast";
        el.innerHTML = `<b>${title}</b><div style="opacity:.92;margin-top:4px">${msg}</div>`;
        toastWrap.appendChild(el);
        setTimeout(() => { el.style.opacity="0"; el.style.transform="translateY(6px)"; }, 2600);
        setTimeout(() => el.remove(), 3100);
      }

      let audioCtx = null;
      function beep(kind){
        try{
          if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const t0 = audioCtx.currentTime;
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = "sine";
          o.frequency.value = kind==="win" ? 880 : kind==="spin" ? 520 : 220;
          g.gain.setValueAtTime(0.0001, t0);
          g.gain.exponentialRampToValueAtTime(kind==="win" ? 0.12 : 0.07, t0+0.01);
          g.gain.exponentialRampToValueAtTime(0.0001, t0 + (kind==="win"?0.25:0.16));
          o.connect(g); g.connect(audioCtx.destination);
          o.start(t0); o.stop(t0 + (kind==="win"?0.27:0.18));
        }catch{}
      }

      const confetti = [];
      function confettiBurst(intensity=1){
        const n = Math.floor(80*intensity);
        for(let i=0;i<n;i++){
          confetti.push({
            x: fxW*(0.2+Math.random()*0.6),
            y: -20,
            vx: (Math.random()-0.5)*6,
            vy: 6+Math.random()*9,
            r: 2+Math.random()*4,
            a: 1,
            rot: Math.random()*Math.PI,
            vr: (Math.random()-0.5)*0.25
          });
        }
      }
      function fxTick(){
        fx.clearRect(0,0,fxW,fxH);
        for(let i=confetti.length-1;i>=0;i--){
          const p = confetti[i];
          p.vy += 0.15;
          p.x += p.vx; p.y += p.vy;
          p.rot += p.vr;
          p.a *= 0.992;
          if(p.y > fxH+60 || p.a < 0.03) confetti.splice(i,1);
          else{
            fx.save();
            fx.globalAlpha = p.a;
            fx.translate(p.x,p.y);
            fx.rotate(p.rot);
            fx.fillStyle = `hsl(${Math.floor((p.x+p.y)%360)}, 90%, 60%)`;
            fx.fillRect(-p.r, -p.r, p.r*2.2, p.r*1.2);
            fx.restore();
          }
        }
        requestAnimationFrame(fxTick);
      }
      fxTick();

      function nowTime(){ return new Date().toLocaleTimeString(); }
      function addHistory(el, text){
        const div = document.createElement("div");
        div.textContent = `${nowTime()} ‚Äî ${text}`;
        el.prepend(div);
      }
      function fmt(n){ return (Number(n)||0).toLocaleString("vi-VN"); }
      function sign(n){ return (n>0?"+":"") + fmt(n); }
      function who(p){ return p ? `P${p}` : "Kh√°ch"; }

      // ===== Multiplayer / state =====
      const mpStatusEl = document.getElementById("mpStatus");
      const roomCodeEl = document.getElementById("roomCode");
      const playerCodeEl = document.getElementById("playerCode");
      const presenceEl = document.getElementById("presence");
      const balP1El = document.getElementById("balP1");
      const balP2El = document.getElementById("balP2");
      const minBetEl = document.getElementById("minBet");
      const maxBetEl = document.getElementById("maxBet");
      const copyLinkBtn = document.getElementById("copyLinkBtn");
      const resetRoomBtn = document.getElementById("resetRoomBtn");

      const qs = new URLSearchParams(location.search);
      const room = qs.get("room") || "demo";
      roomCodeEl.textContent = room;

      copyLinkBtn.addEventListener("click", async () => {
        const link = `${location.origin}/?room=${encodeURIComponent(room)}`;
        try{ await navigator.clipboard.writeText(link); toast("Copied", link); beep("tap"); }
        catch{ toast("Copy failed", link); }
      });

      let socket = null;
      let myPid = 0;
      let limits = { MIN_BET: 10, MAX_BET: 500000, START_BALANCE: 10000 };
      let balances = {1:0,2:0};
      let playerState = {1:{},2:{}};

      function renderBalances(){
        balP1El.textContent = fmt(balances[1] ?? 0);
        balP2El.textContent = fmt(balances[2] ?? 0);
        minBetEl.textContent = fmt(limits.MIN_BET);
        maxBetEl.textContent = fmt(limits.MAX_BET);
      }

      // ===== Cursor =====
      const cursorP1 = document.getElementById("cursorP1");
      const cursorP2 = document.getElementById("cursorP2");
      let currentTab = "wheel";
      function showCursor(by, x, y, tab){
        const el = by === 1 ? cursorP1 : cursorP2;
        if(!el) return;
        if(by === myPid) return;
        el.style.display = "block";
        el.style.left = (x*innerWidth) + "px";
        el.style.top  = (y*innerHeight) + "px";
        el.querySelector(".tag").textContent = `P${by} ¬∑ ${tab || ""}`;
      }

      let lastSend = 0;
      function sendCursor(e){
        if(!socket || !socket.connected) return;
        if(!(myPid===1 || myPid===2)) return;
        const now = performance.now();
        if(now - lastSend < 40) return;
        lastSend = now;
        const x = (e.clientX ?? 0) / innerWidth;
        const y = (e.clientY ?? 0) / innerHeight;
        socket.emit("cursor", { x, y, tab: currentTab });
      }
      addEventListener("mousemove", sendCursor, { passive: true });

      // ===== Tabs =====
      const tabBtns = [...document.querySelectorAll("[data-tab-btn]")];
      const tabs = [...document.querySelectorAll(".tab")];

      function setTab(name, silent=false){
        currentTab = name;
        tabBtns.forEach(b => b.classList.toggle("active", b.getAttribute("data-tab-btn")===name));
        tabs.forEach(t => t.classList.toggle("active", t.getAttribute("data-tab")===name));
        if(!silent && socket && socket.connected){
          socket.emit("player:set", { key:"tab", value:name });
        }
      }
      tabBtns.forEach(btn => {
        btn.addEventListener("click", () => {
          beep("tap");
          const name = btn.getAttribute("data-tab-btn");
          setTab(name, false);
        });
      });

      // ===== Chips helper =====
      const CHIP_VALUES = [10, 50, 100, 500, 1000, 5000];
      function mountChips(container, inputEl, onChange){
        container.innerHTML = "";
        CHIP_VALUES.forEach(v => {
          const b = document.createElement("button");
          b.className = "chipBtn";
          b.textContent = `+${fmt(v)}`;
          b.addEventListener("click", () => {
            beep("tap");
            const cur = Math.floor(Number(inputEl.value || 0));
            inputEl.value = String(Math.max(limits.MIN_BET, cur + v));
            onChange();
          });
          container.appendChild(b);
        });
        const b2 = document.createElement("button");
        b2.className="chipBtn";
        b2.textContent="MIN";
        b2.addEventListener("click", () => { beep("tap"); inputEl.value=String(limits.MIN_BET); onChange(); });
        container.appendChild(b2);

        const b3 = document.createElement("button");
        b3.className="chipBtn";
        b3.textContent="MAX";
        b3.addEventListener("click", () => { beep("tap"); inputEl.value=String(limits.MAX_BET); onChange(); });
        container.appendChild(b3);
      }

      function popResult(el, text){
        el.textContent = text;
        el.classList.remove("pop");
        void el.offsetWidth;
        el.classList.add("pop");
      }

      // ===== Wheel UI =====
      const wheelCanvas = document.getElementById("wheelCanvas");
      const wctx = wheelCanvas.getContext("2d");
      const wheelBetEl = document.getElementById("wheelBet");
      const wheelChipsEl = document.getElementById("wheelChips");
      const wheelSpinBtn = document.getElementById("wheelSpinBtn");
      const wheelClearBtn = document.getElementById("wheelClearBtn");
      const wheelResultEl = document.getElementById("wheelResult");
      const wheelHistoryEl = document.getElementById("wheelHistory");

      const WHEEL_SEGMENTS = [
        { label:"x0",   mult:0.0,  weight:35 },
        { label:"x0.5", mult:0.5,  weight:20 },
        { label:"x1",   mult:1.0,  weight:25 },
        { label:"x2",   mult:2.0,  weight:12 },
        { label:"x3",   mult:3.0,  weight:6  },
        { label:"x10",  mult:10.0, weight:2  }
      ];

      let wheelAngle = 0;
      let wheelSpinning = false;

      function wheelDraw(){
        const W = wheelCanvas.width, H = wheelCanvas.height;
        const cx=W/2, cy=H/2;
        const r=Math.min(W,H)*0.45;

        wctx.clearRect(0,0,W,H);

        const glow = wctx.createRadialGradient(cx,cy,r*0.2,cx,cy,r*1.1);
        glow.addColorStop(0,"rgba(122,92,255,0.18)");
        glow.addColorStop(1,"rgba(0,0,0,0)");
        wctx.fillStyle=glow;
        wctx.beginPath(); wctx.arc(cx,cy,r*1.02,0,Math.PI*2); wctx.fill();

        const n=WHEEL_SEGMENTS.length;
        const slice=(Math.PI*2)/n;

        for(let i=0;i<n;i++){
          const a0=wheelAngle+i*slice;
          const a1=a0+slice;
          wctx.beginPath();
          wctx.moveTo(cx,cy);
          wctx.arc(cx,cy,r,a0,a1);
          wctx.closePath();
          wctx.fillStyle = (i%2===0) ? "rgba(255,255,255,0.10)" : "rgba(255,255,255,0.18)";
          wctx.fill();
          wctx.strokeStyle="rgba(255,255,255,0.10)";
          wctx.lineWidth=2; wctx.stroke();

          wctx.save();
          wctx.translate(cx,cy);
          wctx.rotate(a0+slice/2);
          wctx.textAlign="right";
          wctx.fillStyle="rgba(232,238,246,0.95)";
          wctx.font="900 26px system-ui, -apple-system, Segoe UI, Roboto, Arial";
          wctx.fillText(WHEEL_SEGMENTS[i].label, r-18, 10);
          wctx.restore();
        }

        // center cap
        wctx.beginPath(); wctx.arc(cx,cy,r*0.14,0,Math.PI*2);
        wctx.fillStyle="rgba(8,10,16,.92)"; wctx.fill();
        wctx.strokeStyle="rgba(255,255,255,0.12)"; wctx.lineWidth=2; wctx.stroke();

        // pointer
        wctx.beginPath();
        wctx.moveTo(cx, cy - r - 22);
        wctx.lineTo(cx - 18, cy - r + 14);
        wctx.lineTo(cx + 18, cy - r + 14);
        wctx.closePath();
        wctx.fillStyle="#2b7fff";
        wctx.fill();
      }

      function wheelIndexAtPointer(){
        const n=WHEEL_SEGMENTS.length;
        const slice=(Math.PI*2)/n;
        let a=wheelAngle%(Math.PI*2);
        if(a<0) a+=Math.PI*2;
        const pointer = Math.PI*1.5;
        let rel = pointer - a;
        rel = rel%(Math.PI*2);
        if(rel<0) rel+=Math.PI*2;
        return Math.floor(rel/slice)%n;
      }

      function wheelSpinTo(targetIndex){
        if(wheelSpinning) return;
        wheelSpinning=true;
        wheelSpinBtn.disabled=true;

        const current=wheelIndexAtPointer();
        const n=WHEEL_SEGMENTS.length;
        const slice=(Math.PI*2)/n;

        let delta=(targetIndex-current);
        if(delta<0) delta+=n;

        const baseTurns=8;
        const totalRotation=(baseTurns*Math.PI*2)+(delta*slice);

        const startAngle=wheelAngle;
        const duration=2200;
        const t0=performance.now();
        const easeOut=t => 1 - Math.pow(1-t,3);

        beep("spin");

        function frame(t){
          const p=Math.min(1,(t-t0)/duration);
          wheelAngle = startAngle + totalRotation*easeOut(p);
          wheelDraw();
          if(p<1) requestAnimationFrame(frame);
          else{
            wheelSpinning=false;
            wheelSpinBtn.disabled=false;
          }
        }
        requestAnimationFrame(frame);
      }

      wheelDraw();

      function setWheelBet(){
        const v = Math.floor(Number(wheelBetEl.value || limits.MIN_BET));
        wheelBetEl.value = String(Math.max(limits.MIN_BET, Math.min(limits.MAX_BET, v)));
        if(socket && socket.connected && (myPid===1 || myPid===2)){
          socket.emit("player:set", { key:"wheelBet", value:Number(wheelBetEl.value) });
        }
      }

      wheelBetEl.addEventListener("input", () => setWheelBet());
      wheelSpinBtn.addEventListener("click", () => { beep("spin"); socket?.emit("wheel:spin"); });
      wheelClearBtn.addEventListener("click", () => { wheelHistoryEl.innerHTML=""; popResult(wheelResultEl,"‚Äî"); beep("tap"); });

      // ===== Tai/Xiu UI =====
      const txPickEl = document.getElementById("txPick");
      const txBetEl = document.getElementById("txBet");
      const txChipsEl = document.getElementById("txChips");
      const txRollBtn = document.getElementById("txRollBtn");
      const txClearBtn = document.getElementById("txClearBtn");
      const txResultEl = document.getElementById("txResult");
      const txHistoryEl = document.getElementById("txHistory");
      const diceFaces = ["‚öÄ","‚öÅ","‚öÇ","‚öÉ","‚öÑ","‚öÖ"];

      function setTxPick(){
        if(socket && socket.connected && (myPid===1 || myPid===2)){
          socket.emit("player:set", { key:"txPick", value:txPickEl.value });
        }
      }
      function setTxBet(){
        const v = Math.floor(Number(txBetEl.value || limits.MIN_BET));
        txBetEl.value = String(Math.max(limits.MIN_BET, Math.min(limits.MAX_BET, v)));
        if(socket && socket.connected && (myPid===1 || myPid===2)){
          socket.emit("player:set", { key:"txBet", value:Number(txBetEl.value) });
        }
      }

      txPickEl.addEventListener("change", () => { beep("tap"); setTxPick(); });
      txBetEl.addEventListener("input", () => setTxBet());
      txRollBtn.addEventListener("click", () => { beep("spin"); socket?.emit("tx:roll"); });
      txClearBtn.addEventListener("click", () => { txHistoryEl.innerHTML=""; popResult(txResultEl,"‚Äî"); beep("tap"); });

      // ===== Blackjack UI =====
      const bjBetEl = document.getElementById("bjBet");
      const bjChipsEl = document.getElementById("bjChips");
      const bjDealBtn = document.getElementById("bjDealBtn");
      const bjNewBtn = document.getElementById("bjNewBtn");
      const bjHitBtn = document.getElementById("bjHitBtn");
      const bjStandBtn = document.getElementById("bjStandBtn");
      const bjDealerHandEl = document.getElementById("bjDealerHand");
      const bjPlayerHandEl = document.getElementById("bjPlayerHand");
      const bjResultEl = document.getElementById("bjResult");
      const bjHistoryEl = document.getElementById("bjHistory");

      function cardText(c){ return `${c.r}${c.s}`; }
      function handValue(hand){
        let total=0, aces=0;
        for(const c of hand){
          if(c.r==="A"){ aces++; total+=11; }
          else if(["K","Q","J"].includes(c.r)) total+=10;
          else total+=Number(c.r);
        }
        while(total>21 && aces>0){ total-=10; aces--; }
        return total;
      }

      function setBjBet(){
        const v = Math.floor(Number(bjBetEl.value || limits.MIN_BET));
        bjBetEl.value = String(Math.max(limits.MIN_BET, Math.min(limits.MAX_BET, v)));
        if(socket && socket.connected && (myPid===1 || myPid===2)){
          socket.emit("player:set", { key:"bjBet", value:Number(bjBetEl.value) });
        }
      }
      bjBetEl.addEventListener("input", () => setBjBet());

      bjDealBtn.addEventListener("click", () => { beep("spin"); socket?.emit("bj:deal"); });
      bjHitBtn.addEventListener("click", () => { beep("tap"); socket?.emit("bj:hit"); });
      bjStandBtn.addEventListener("click", () => { beep("tap"); socket?.emit("bj:stand"); });
      bjNewBtn.addEventListener("click", () => { beep("tap"); socket?.emit("bj:new"); });

      function renderBj(bj){
        bjDealerHandEl.innerHTML="";
        bjPlayerHandEl.innerHTML="";

        (bj.dealer||[]).forEach((c, idx) => {
          const chip=document.createElement("div");
          chip.className="cardchip";
          chip.textContent = (bj.inRound && bj.dealerHidden && idx===1) ? "‚ùì" : cardText(c);
          bjDealerHandEl.appendChild(chip);
        });

        (bj.player||[]).forEach(c => {
          const chip=document.createElement("div");
          chip.className="cardchip";
          chip.textContent=cardText(c);
          bjPlayerHandEl.appendChild(chip);
        });

        const pVal = handValue(bj.player||[]);
        const dVal = handValue(bj.dealer||[]);
        const turn = bj.turn || 1;

        const isMyTurn = (myPid===turn);
        const canAct = bj.inRound && isMyTurn && (bj.wagerPid===myPid);

        bjDealBtn.disabled = bj.inRound || !isMyTurn || !(myPid===1 || myPid===2);
        bjHitBtn.disabled = !canAct;
        bjStandBtn.disabled = !canAct;

        const dealerText = (bj.inRound && bj.dealerHidden) ? "?" : String(dVal);
        const wagerText = bj.wager ? ` | c∆∞·ª£c ${fmt(bj.wager)}` : "";
        popResult(bjResultEl, `L∆∞·ª£t: P${turn}${wagerText} | B·∫°n ${pVal} | Dealer ${dealerText}`);

        if(!bj.inRound && bj.lastOutcome){
          const outcome = bj.lastOutcome;
          const profit = bj.lastProfit || 0;
          const labelMap = {
            win: "TH·∫ÆNG",
            lose: "THUA",
            push: "H√íA",
            blackjack: "BLACKJACK",
            bust: "BUST"
          };
          const label = labelMap[outcome] || outcome;
          addHistory(bjHistoryEl, `${label} | ${profit>=0?"+":""}${fmt(profit)} chip`);
          if(outcome==="win" || outcome==="blackjack"){ confettiBurst(1.0); beep("win"); }
          if(outcome==="lose" || outcome==="bust"){ beep("tap"); }
        }
      }

      // ===== Roulette UI =====
      const rlBetTypeEl = document.getElementById("rlBetType");
      const rlNumberWrap = document.getElementById("rlNumberWrap");
      const rlNumberEl = document.getElementById("rlNumber");
      const rlBetEl = document.getElementById("rlBet");
      const rlChipsEl = document.getElementById("rlChips");
      const rlSpinBtn = document.getElementById("rlSpinBtn");
      const rlClearBtn = document.getElementById("rlClearBtn");
      const rlResultEl = document.getElementById("rlResult");
      const rlGridEl = document.getElementById("rlGrid");
      const rlHistoryEl = document.getElementById("rlHistory");
      const redNums = new Set([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]);

      function rlColor(n){ if(n===0) return "green"; return redNums.has(n)?"red":"black"; }

      function rlBuildGrid(){
        rlGridEl.innerHTML="";
        for(let n=0;n<=36;n++){
          const cell=document.createElement("div");
          cell.className=`roulette-cell ${rlColor(n)}`;
          cell.setAttribute("data-num", String(n));
          cell.innerHTML=`<span>${n}</span><span style="opacity:.8;font-size:12px">${rlColor(n).toUpperCase()}</span>`;
          rlGridEl.appendChild(cell);
        }
      }
      function rlHighlight(n){
        [...rlGridEl.querySelectorAll(".roulette-cell")].forEach(c=>c.classList.remove("active"));
        const hit=rlGridEl.querySelector(`.roulette-cell[data-num="${n}"]`);
        if(hit) hit.classList.add("active");
      }
      rlBuildGrid();

      function updateRlNumberWrap(){
        rlNumberWrap.style.display = (rlBetTypeEl.value==="number") ? "block" : "none";
      }

      function setRlBetType(){
        updateRlNumberWrap();
        if(socket && socket.connected && (myPid===1 || myPid===2)){
          socket.emit("player:set", { key:"rlBetType", value: rlBetTypeEl.value });
        }
      }
      function setRlNumber(){
        const v = Math.floor(Number(rlNumberEl.value||0));
        rlNumberEl.value = String(Math.max(0, Math.min(36, v)));
        if(socket && socket.connected && (myPid===1 || myPid===2)){
          socket.emit("player:set", { key:"rlNumber", value: Number(rlNumberEl.value) });
        }
      }
      function setRlBet(){
        const v = Math.floor(Number(rlBetEl.value || limits.MIN_BET));
        rlBetEl.value = String(Math.max(limits.MIN_BET, Math.min(limits.MAX_BET, v)));
        if(socket && socket.connected && (myPid===1 || myPid===2)){
          socket.emit("player:set", { key:"rlBet", value: Number(rlBetEl.value) });
        }
      }

      rlBetTypeEl.addEventListener("change", () => { beep("tap"); setRlBetType(); });
      rlNumberEl.addEventListener("input", () => setRlNumber());
      rlBetEl.addEventListener("input", () => setRlBet());
      rlSpinBtn.addEventListener("click", () => { beep("spin"); socket?.emit("rl:spin"); });
      rlClearBtn.addEventListener("click", () => { rlHistoryEl.innerHTML=""; rlHighlight(-1); popResult(rlResultEl,"‚Äî"); beep("tap"); });

      // ===== Reset room =====
      resetRoomBtn.addEventListener("click", () => {
        beep("tap");
        if(!socket || !socket.connected) return;
        if(myPid !== 1){
          toast("Reset", "Ch·ªâ P1 reset ph√≤ng.");
          return;
        }
        if(confirm("Reset ph√≤ng? (balance v·ªÅ m·∫∑c ƒë·ªãnh)")) socket.emit("room:reset");
      });

      // ===== Chips mount =====
      function mountAllChips(){
        mountChips(wheelChipsEl, wheelBetEl, setWheelBet);
        mountChips(txChipsEl, txBetEl, setTxBet);
        mountChips(bjChipsEl, bjBetEl, setBjBet);
        mountChips(rlChipsEl, rlBetEl, setRlBet);
      }

      // ===== Connect socket =====
      try{
        socket = io({ query: { room }, transports: ["websocket"] });

        socket.on("connect", () => {
          mpStatusEl.textContent="Online";
          toast("K·∫øt n·ªëi", "ƒê√£ v√†o ph√≤ng");
        });

        socket.on("disconnect", () => {
          mpStatusEl.textContent="Offline";
          toast("M·∫•t k·∫øt n·ªëi", "Render c√≥ th·ªÉ ƒëang sleep, th·ª≠ t·∫£i l·∫°i");
        });

        socket.on("error:msg", (d) => {
          toast("L·ªói", d?.msg || "C√≥ l·ªói");
          beep("tap");
        });

        socket.on("presence", data => {
          const ps = (data.players||[]).map(p=>`P${p}`).join(", ");
          presenceEl.textContent = ps || "‚Äî";
        });

        socket.on("cursor", d => {
          showCursor(d.by, d.x, d.y, d.tab);
        });

        socket.on("init", data => {
          myPid = data.playerId || 0;
          playerCodeEl.textContent = myPid ? `P${myPid}` : "Kh√°ch";

          limits = data.limits || limits;
          balances = data.balances || balances;
          playerState = data.player || playerState;

          renderBalances();
          mountAllChips();

          // apply my state into inputs
          if(myPid===1 || myPid===2){
            const st = playerState[myPid] || {};
            wheelBetEl.value = String(st.wheelBet ?? limits.MIN_BET);
            txPickEl.value = st.txPick ?? "tai";
            txBetEl.value = String(st.txBet ?? limits.MIN_BET);
            bjBetEl.value = String(st.bjBet ?? limits.MIN_BET);
            rlBetTypeEl.value = st.rlBetType ?? "red";
            rlNumberEl.value = String(st.rlNumber ?? 7);
            rlBetEl.value = String(st.rlBet ?? limits.MIN_BET);
            updateRlNumberWrap();

            const tab = st.tab || "wheel";
            setTab(tab, true);
          }else{
            // spectator: v·∫´n cho xem
            setTab("wheel", true);
          }

          // wheel
          wheelDraw();

          // blackjack
          if(data.bj) renderBj(data.bj);

          toast("V√≠ chip", `Start balance: ${fmt(limits.START_BALANCE)} (demo)`);
        });

        socket.on("state:full", data => {
          balances = data.balances || balances;
          playerState = data.player || playerState;
          renderBalances();
        });

        socket.on("player:set", d => {
          // ƒë·ªìng b·ªô selections c·ªßa ng∆∞·ªùi kia n·∫øu mu·ªën (ƒë·ªÉ "th·∫•y thao t√°c")
          if(!d || !d.by) return;
          const by = d.by;

          playerState[by] = playerState[by] || {};
          playerState[by][d.key] = d.value;

          // N·∫øu event n√†y c·ªßa ch√≠nh m√¨nh th√¨ b·ªè
          if(by === myPid) return;

          // Hi·ªÉn th·ªã toast thao t√°c
          if(d.key === "tab") toast("Tab", `${who(by)} m·ªü ${d.value}`);
          if(d.key === "txPick") toast("T√†i/X·ªâu", `${who(by)} ch·ªçn ${d.value === "tai" ? "T√ÄI" : "X·ªàU"}`);
          if(d.key === "rlBetType") toast("Roulette", `${who(by)} c∆∞·ª£c ki·ªÉu ${d.value}`);
          if(d.key === "rlNumber") toast("Roulette", `${who(by)} ch·ªçn s·ªë ${d.value}`);
        });

        socket.on("room:reset", snap => {
          balances = snap.balances || balances;
          playerState = snap.player || playerState;
          renderBalances();

          wheelHistoryEl.innerHTML="";
          txHistoryEl.innerHTML="";
          bjHistoryEl.innerHTML="";
          rlHistoryEl.innerHTML="";
          popResult(wheelResultEl,"‚Äî");
          popResult(txResultEl,"‚Äî");
          popResult(bjResultEl,"‚Äî");
          popResult(rlResultEl,"‚Äî");
          rlHighlight(-1);

          if(myPid===1 || myPid===2){
            const st = playerState[myPid] || {};
            wheelBetEl.value = String(st.wheelBet ?? limits.MIN_BET);
            txPickEl.value = st.txPick ?? "tai";
            txBetEl.value = String(st.txBet ?? limits.MIN_BET);
            bjBetEl.value = String(st.bjBet ?? limits.MIN_BET);
            rlBetTypeEl.value = st.rlBetType ?? "red";
            rlNumberEl.value = String(st.rlNumber ?? 7);
            rlBetEl.value = String(st.rlBet ?? limits.MIN_BET);
            updateRlNumberWrap();
            setTab(st.tab || "wheel", true);
          }

          toast("Reset", "Ph√≤ng ƒë√£ reset v·ªÅ m·∫∑c ƒë·ªãnh");
          beep("tap");
        });

        // ===== Wheel result =====
        socket.on("wheel:result", r => {
          balances = r.balances || balances;
          renderBalances();

          const seg = r.segment;
          const msg = `${who(r.by)} c∆∞·ª£c ${fmt(r.bet)} ‚Üí ${seg.label} | profit ${sign(r.profit)} | bal ${fmt(balances[r.by])}`;
          addHistory(wheelHistoryEl, msg);

          popResult(wheelResultEl, `${seg.label} | c∆∞·ª£c ${fmt(r.bet)} | ${r.profit>=0?"+":""}${fmt(r.profit)} | bal ${fmt(balances[r.by])}`);

          wheelSpinTo(r.segmentIndex);

          if(r.profit > 0){ confettiBurst(seg.mult >= 3 ? 1.1 : 0.7); beep("win"); }
          else beep("tap");
        });

        // ===== Tai/Xiu result =====
        socket.on("tx:result", r => {
          balances = r.balances || balances;
          renderBalances();

          const outLabel = (r.out === "tai") ? "T√ÄI" : "X·ªàU";
          const pickLabel = (r.pick === "tai") ? "T√ÄI" : "X·ªàU";
          const tripleText = r.triple ? " (TRIPLE!)" : "";
          const res = `${diceFaces[r.d1-1]} ${diceFaces[r.d2-1]} ${diceFaces[r.d3-1]} | ${r.sum}${tripleText} ‚Üí ${outLabel} | B·∫°n: ${pickLabel} | ${r.win?"WIN":"LOSE"} | profit ${sign(r.profit)} | bal ${fmt(balances[r.by])}`;

          popResult(txResultEl, res);
          addHistory(txHistoryEl, `${who(r.by)} c∆∞·ª£c ${fmt(r.bet)} | ${r.win?"WIN":"LOSE"} | ${sign(r.profit)} | bal ${fmt(balances[r.by])}`);

          if(r.win){ confettiBurst(0.9); beep("win"); }
          else beep("tap");
        });

        // ===== Roulette result =====
        socket.on("rl:result", r => {
          balances = r.balances || balances;
          renderBalances();

          rlHighlight(r.rolled);

          const betLabelMap = {
            red:"ƒê·ªé", black:"ƒêEN", odd:"L·∫∫", even:"CH·∫¥N", low:"1‚Äì18", high:"19‚Äì36",
            number:`S·ªê ${r.betNumber}`
          };
          const betLabel = (r.betType === "number") ? `S·ªê ${r.betNumber}` : (betLabelMap[r.betType] || r.betType);

          popResult(rlResultEl, `Ra ${r.rolled} (${String(r.color).toUpperCase()}) | ${betLabel} | c∆∞·ª£c ${fmt(r.bet)} | profit ${sign(r.profit)} | bal ${fmt(balances[r.by])}`);
          addHistory(rlHistoryEl, `${who(r.by)}: ${r.rolled} ${r.win?"WIN":"LOSE"} | ${sign(r.profit)} | bal ${fmt(balances[r.by])}`);

          if(r.win){ confettiBurst(r.betType==="number" ? 1.2 : 0.8); beep("win"); }
          else beep("tap");
        });

        // ===== Blackjack state =====
        socket.on("bj:state", pack => {
          balances = pack.balances || balances;
          renderBalances();
          renderBj(pack.bj || {});
        });

      }catch{
        mpStatusEl.textContent="Offline";
      }
    })();
  </script>
</body>
</html>
